---
title: "SET Rate Calculations"
date: "`r Sys.Date()`"
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

Everything in this report currently uses ALL reported data values. Quality flags were ignored, which may lead to differences in final numbers once we deal with QA/QC issues.  

Also, be aware that linear regression as a way to calculate rate of change is not appropriate at all sites. Use discretion about these results.  

Rates of change were calculated first for each pin using a linear model of pin_height vs. date. Rates were converted from mm/day to mm/year by multiplying by 365.25 (to account for leap years). So linear models result in 36 rates of change per SET.  

Rates from the 36 pins were averaged to one rate per SET. This is the rate reported here.    

Note that, provided no data are missing, this rate is the same as the rate generated by averaging all the 9 pins per arm and then averaging the 4 arms' rates together. Variance is, however, different.  

# Setup  

The following R packages are required to generate this report:  

```{r load_libraries, echo = TRUE}
library(knitr)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(nlme)
library(broom)
library(here)
funs_path <- here::here('R', '000_functions.R')
source(funs_path)
```


## Read in data  

This reads in the long dataset, converted from other formats by earlier scripts. It also converts pin heights to mm if they weren't already in those units.    

```{r read_data}
path <- here::here('data/intermediate')
dat <- read_csv(paste0(path, '/GND.csv'))

# make sure pin heights are in mm
dat <- height_to_mm(dat)

# get rid of any placeholders; make sure date is proper format  
dat <- dat %>%
    filter(!is.na(date),
           !is.na(pin_number)) %>%
    mutate(date = as.Date(date),
           set_id = as.factor(set_id))
```

Other reserve-specific inputs here (e.g., NAVD-88 heights of SET receivers; local rate of SLR; etc)  

```{r}
# local rate of sea level rise, in mm/yr
slr <- 3.61
slr_ci <- 0.59
```


***

# Rate Calculations  

## Pin level  

Calculate a linear rate of change for each pin at each SET.  

**Linear regression for each pin.** Keeping errors and confidence intervals in here just so we can describe the linear regression model should it ever be necessary. But really we'll only be working with *rate_mm.yr* from here on out.  

Note that the Confidence Intervals here were generated by the lm() function.  

These values are not shown but can be if people want them.  


```{r, rows.print = 9}
# generate linear model for each pin
models <- dat %>%
    group_by(reserve, set_id, arm_position, pin_number) %>%
    do(mod = lm(pin_height ~ date, data = .))  


# pull out coefficients of interest:
# intercept, slope, p-value, 95% confidence bounds
modelcoef <- tidy(models, mod, conf.int=TRUE, conf.level=0.95) 


# get rid of intercept row,
# calculate mm/yr for all the terms,
# get rid of the mm/day stuff
# p-value and statistic are rounded
rates_elev_pins <- modelcoef %>%
    filter(term == "date") %>%
    mutate(rate_mm.yr = estimate*365.25,
           se_mm.yr = std.error*365.25,
           CIlow_mm.yr = conf.low*365.25,
           CIhigh_mm.yr = conf.high*365.25,
           p_value = round(p.value, 4),
           statistic = round(statistic, 3)) %>%
    select(reserve, set_id, arm_position, pin_number, rate_mm.yr, se_mm.yr, CIlow_mm.yr, CIhigh_mm.yr, statistic, p_value)


# calculate r^2, adjusted r^2, p values, and other model diagnostics
modelsummary_pins <- glance(models, mod) 
```


***


## SET level: All rates  

Average of the 36 pins' rates.  

95% Confidence Intervals are calculated as:  
`mean +/- [1.96 * standard error]`  

<br>

```{r}
rates_elev_set <- rates_elev_pins %>%
    group_by(reserve, set_id) %>%
    summarize(rate_mm.yr_set = mean(rate_mm.yr, na.rm = TRUE),
              sd_mm.yr = sd(rate_mm.yr, na.rm = TRUE),
              se_mm.yr = sd_mm.yr/sqrt(n())) %>%
    mutate(CI95_low = rate_mm.yr_set - 1.96*se_mm.yr,
           CI95_high = rate_mm.yr_set + 1.96*se_mm.yr) %>%
    ungroup()

knitr::kable(rates_elev_set,
             caption = "Rate of Elevation Change by SET", 
             col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "stdev", "sterr", "95% CI lower bound", "95% CI upper bound"),
             digits = 3,
             align = 'c')
```

***


# Sea Level Rise Comparisons  

The local rate of sea level rise was input as **`r slr` +/- `r slr_ci` mm/yr** .

The following tables break the SETs into groups where the rate of SET elevation change is *lower than* / *higher than* / *not different from* this SLR rate.  

95% Confidence Intervals are calculated as:  
`mean +/- [1.96 * standard error]`  

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_high < slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where elevation change is lower than SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_low > slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where elevation change is higher than SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_low < slr & CI95_high > slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where the 95% CI for elevation change rate includes SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

***  

# Graph  

for a sanity check of the above rates  

Linear regression is NOT appropriate for all sites; interpret this with caution

```{r, fig.width = 7, fig.height = 9}
ggplot(dat, aes(x = date, y = pin_height)) +
    geom_point(aes(col = arm_position), alpha = 0.6) +
    facet_wrap(~set_id, ncol = 4, scales = "free_y") +
    geom_smooth(method = 'lm', se = FALSE, size = 2, col = "black") +
    labs(title = "Pin readings by date", subtitle = "with linear regression through all pins", x = "Date", y = "Pin Height (mm)") +
    scale_fill_discrete(name = 'Arm Position') +
    theme_bw() +
    theme(legend.position = 'bottom')
```

# Another graph  

To visualize confidence intervals; because calculated SLR rate also has a standard error  

```{r, fig.width = 7, fig.height = 6}
ggplot() +
    geom_blank(data = rates_elev_set, aes(x = set_id, y = rate_mm.yr_set)) +
    geom_ribbon(aes(x = 0:(nrow(rates_elev_set)+1), ymin = slr-slr_ci, ymax = slr+slr_ci), fill = "navyblue", alpha = 0.1) +
    geom_hline(aes(yintercept = slr), col = "navyblue", size = 1, alpha = 0.9) +
    geom_hline(aes(yintercept = 0), col = "gray70") +
    geom_errorbar(data = rates_elev_set, aes(x = set_id, ymin = CI95_low, ymax = CI95_high), col = "gray55", size = 1) +
    geom_point(data = rates_elev_set, aes(x = set_id, y = rate_mm.yr_set), size = 3, col = "red3") +
    theme_classic() + 
    labs(title = "Elevation Change, 95% Confidence Intervals", subtitle = paste0("Local SLR in blue: ", slr, " +/- ", slr_ci, " mm/yr"), x = "SET", y = "Rate of change (mm/yr)") +
    coord_flip()
```


***
***

# Linear Mixed Models  

Some experimentation with linear mixed models for rate. From Cahoon et al. 2018:

Linear mixed models (LMMs, Zuur et al. 2009) were chosen
to analyze the surface elevation data. LMMs are ideal for
analyzing the nested longitudinal data that is produced by
the SET device. Rather than averaging the pin heights from
each SET prior to analysis, the measurements from each pin
are used as separate replicates. This preserves the variation
found within each SET and also maximizes statistical power.
Effects which are specific to each SET, direction within each
SET, and pin within each direction are treated as random
effects, which account for the lack of independence among
pins on the same SET. Analysis was performed using
mixed-effect models in the nlme package (Pinheiro et al.
2016) in R version 3.3.2 (R Core Team 2016).
Data from each of the five sites were analyzed separately.
Pin height (m, NAVD88) served as the response variable, and
the fixed effects were the number of days since the initial
reading was taken. To account for a potential reduction of
independence among pins on the same SET, the model included
a random slope and intercept for each pin, nested in the SET
position on the benchmark (typically, four positions were read
during each sampling event), nested in the SET. This model
was first fit using maximum likelihood. It was then compared
to a model with identical random effects but an intercept-only
fixed effect using the corrected form of Akaikeâ€™s information
criterion (AICc, Akaike 1974, Burnham and Anderson 2004).
If the intercept-only model was superior, this indicated that
there is no trend in elevation over time. The model including
a trend through time was then refit using restricted maximum
likelihood to estimate the coefficients of the regression. For
comparative purposes, this was done even in cases where the
intercept-only model was superior.


So in our case, we have, for each SET:  

+  response variable: pin_height  
+  fixed effect: date  
+  random effects: arm_position, pin_number  (note, these are nested)  

### Pull out one SET to experiment  

```{r}
test <- dat %>%
    filter(set_id == unique(set_id)[1])
```

### model  

```{r}
modelrate <- lme(pin_height ~ date, data = test, random = ~1|arm_position/pin_number, na.action = na.omit)
summary(modelrate)
```

### pull out the rate result  

```{r}
model_mm.d <- modelrate$coefficients$fixed[2]
model_mm.yr <- model_mm.d * 365.25
model_mm.yr
model_se_mm.d <- modelrate$coefficients
```

```{r}
model_mm.d <- summary(modelrate)$tTable[2, 1]
model_se_mm.d <- summary(modelrate)$tTable[2, 2]

model_mm.yr <- model_mm.d * 365.25
model_se_mm.yr <- model_se_mm.d * 365.25
```

For `r unique(dat$set_id)[1]`, the overall calculated rate of change is `r model_mm.yr` with a standard error of `r model_se_mm.yr`.

95% CI is then: ( `r model_mm.yr - 1.96*model_se_mm.yr` , `r model_mm.yr + 1.96*model_se_mm.yr`)


Can you use broom with lme?

```{r}
models2 <- dat %>%
    group_by(reserve, set_id) %>%
    do(mod = lme(pin_height ~ date, data = ., random = ~1|arm_position/pin_number, na.action = na.omit)) 
```

```{r}
modelcoef2 <- tidy(models2, mod, effects = "fixed", conf.int=TRUE, conf.level=0.95) %>%
    filter(term == "date") %>%
    mutate(rate_mm.yr = estimate*365.25,
           se_mm.yr = std.error*365.25,
           CIlow_mm.yr = rate_mm.yr - 1.96*se_mm.yr,
           CIhigh_mm.yr = rate_mm.yr + 1.96*se_mm.yr,
           p_value = round(p.value, 4),
           statistic = round(statistic, 3)) %>%
    select(reserve, set_id, rate_mm.yr, se_mm.yr, CIlow_mm.yr, CIhigh_mm.yr, statistic, p_value)

kable(modelcoef2, caption = "lme estimates of change by SET", 
      digits = 3,
      align = 'c')
```

See other stuff produced by the models:  

```{r}
kable(glance(models2, mod))
```

