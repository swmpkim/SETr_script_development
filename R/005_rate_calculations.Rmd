---
title: "SET Rate Calculations"
date: "`r Sys.Date()`"
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

Everything in this report currently uses ALL reported data values. Quality flags were ignored, which may lead to differences in final numbers once we deal with QA/QC issues.  

Also, be aware that linear regression as a way to calculate rate of change is not appropriate at all sites. Use discretion about these results.  

Rates of change were calculated first for each pin using a linear model of pin_height vs. date. Rates were converted from mm/day to mm/year by multiplying by 365.25 (to account for leap years). So linear models result in 36 rates of change per SET.  

Rates from the 9 pins on each arm were then averaged together, yielding four rates of change per SET.  

Finally, the 4 rates from the arms were averaged to produce one overall rate of change per SET. That is the rate reported here.  

Note that, provided no data are missing, this rate is the same as the rate generated by averaging all 36 rates together and ignoring arm position. Variance is, however, different.  

# Setup  

The following R packages are required to generate this report:  

```{r load_libraries, echo = TRUE}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(broom)
library(here)
```


## Read in data  

This reads in the long dataset, converted from other formats by earlier scripts. It also converts pin heights to mm if they weren't already in those units.    

```{r read_data}
path <- here::here('data/intermediate')
dat <- read_csv(paste0(path, '/WQB.csv'))

# make sure pin heights are in mm
if(exists('pin_height_cm', dat)) {
dat <- dat %>%
    mutate(pin_height = pin_height_cm * 10) %>%
    select(-pin_height_cm)
}
if(exists('pin_height_mm', dat)){
    dat <- dat %>%
        mutate(pin_height = pin_height_mm) %>%
        select(-pin_height_mm)
}

# get rid of any placeholders; make sure date is proper format  
dat <- dat %>%
    filter(!is.na(date),
           !is.na(pin_number)) %>%
    mutate(date = as.Date(date))
```

Other reserve-specific inputs here (e.g., NAVD-88 heights of SET receivers; local rate of SLR; etc)  

```{r}
# local rate of sea level rise, in mm/yr
slr <- 2.86
slr_ci <- 0.17
```


***

# Rate Calculations  

## Pin level  

Calculate a linear rate of change for each pin at each SET.  

**Linear regression for each pin.** Keeping errors and confidence intervals in here just so we can describe the linear regression model should it ever be necessary. But really we'll only be working with *rate_mm.yr* from here on out.  

Note that the Confidence Intervals here were generated by the lm() function.  

These values are not shown but can be if people want them.  


```{r, rows.print = 9}
# generate linear model for each pin
models <- dat %>%
    group_by(reserve, set_id, arm_position, pin_number) %>%
    do(mod = lm(pin_height ~ date, data = .))  


# pull out coefficients of interest:
# intercept, slope, p-value, 95% confidence bounds
modelcoef <- tidy(models, mod, conf.int=TRUE, conf.level=0.95) 


# get rid of intercept row,
# calculate mm/yr for all the terms,
# get rid of the mm/day stuff
# p-value and statistic are rounded
rates_elev_pins <- modelcoef %>%
    filter(term == "date") %>%
    mutate(rate_mm.yr = estimate*365.25,
           se_mm.yr = std.error*365.25,
           CIlow_mm.yr = conf.low*365.25,
           CIhigh_mm.yr = conf.high*365.25,
           p_value = round(p.value, 4),
           statistic = round(statistic, 3)) %>%
    select(reserve, set_id, arm_position, pin_number, rate_mm.yr, se_mm.yr, CIlow_mm.yr, CIhigh_mm.yr, statistic, p_value)


# calculate r^2, adjusted r^2, p values, and other model diagnostics
modelsummary_pins <- glance(models, mod) 
```

## Arm Level  

The average of 9 pins in an arm. Again, values are not shown, but can be.  

```{r}
rates_elev_arms <- rates_elev_pins %>%
    group_by(reserve, set_id, arm_position) %>%
    summarize(rate_mm.yr_arm = mean(rate_mm.yr, na.rm = TRUE),
              sd_mm.yr = sd(rate_mm.yr, na.rm = TRUE),
              se_mm.yr = sd_mm.yr/sqrt(n())) %>%
    ungroup()
```

***


## SET level: All rates  

Average of the 4 arms.  

95% Confidence Intervals are calculated as:  
`mean +/- [1.96 * standard error]`  

<br>

```{r}
rates_elev_set <- rates_elev_arms %>%
    group_by(reserve, set_id) %>%
    summarize(rate_mm.yr_set = mean(rate_mm.yr_arm, na.rm = TRUE),
              sd_mm.yr = sd(rate_mm.yr_arm, na.rm = TRUE),
              se_mm.yr = sd_mm.yr/sqrt(n())) %>%
    mutate(CI95_low = rate_mm.yr_set - 1.96*se_mm.yr,
           CI95_high = rate_mm.yr_set + 1.96*se_mm.yr) %>%
    ungroup()

knitr::kable(rates_elev_set,
             caption = "Rate of Elevation Change by SET", 
             col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "stdev", "sterr", "95% CI lower bound", "95% CI upper bound"),
             digits = 3,
             align = 'c')
```

***


# Sea Level Rise Comparisons  

The local rate of sea level rise was input as **`r slr` +/- `r slr_ci` mm/yr** .

The following tables break the SETs into groups where the rate of SET elevation change is *lower than* / *higher than* / *not different from* this SLR rate.  

95% Confidence Intervals are calculated as:  
`mean +/- [1.96 * standard error]`  

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_high < slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where elevation change is lower than SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_low > slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where elevation change is higher than SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

<br>

***

<br>

```{r}
rates_elev_set %>%
    filter(CI95_low < slr & CI95_high > slr) %>%
    select(reserve, set_id, rate_mm.yr_set, CI95_low, CI95_high) %>%
    knitr::kable(caption = "SETs where the 95% CI for elevation change rate includes SLR",
                 col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "95% CI lower bound", "95% CI upper bound"),
                 digits = 3,
                 align = 'c')
```

***  

# Graph  

for a sanity check of the above rates  

Linear regression is NOT appropriate for all sites; interpret this with caution

```{r, fig.width = 7, fig.height = 9}
ggplot(dat, aes(x = date, y = pin_height)) +
    geom_point(aes(col = arm_position), alpha = 0.6) +
    facet_wrap(~set_id, ncol = 4, scales = "free_y") +
    geom_smooth(method = 'lm', se = FALSE, size = 2, col = "black") +
    labs(title = "Pin readings by date", subtitle = "with linear regression through all pins", x = "Date", y = "Pin Height (mm)") +
    scale_fill_discrete(name = 'Arm Position') +
    theme_bw() +
    theme(legend.position = 'bottom')
```

# Another graph  

To visualize confidence intervals; because calculated SLR rate also has a standard error  

```{r, fig.width = 7, fig.height = 6}
ggplot() +
    geom_blank(data = rates_elev_set, aes(x = set_id, y = rate_mm.yr_set)) +
    geom_ribbon(aes(x = 0:(nrow(rates_elev_set)+1), ymin = slr-slr_ci, ymax = slr+slr_ci), fill = "navyblue", alpha = 0.1) +
    geom_hline(aes(yintercept = slr), col = "navyblue", size = 1, alpha = 0.9) +
    geom_hline(aes(yintercept = 0), col = "gray70") +
    geom_errorbar(data = rates_elev_set, aes(x = set_id, ymin = CI95_low, ymax = CI95_high), col = "gray55", size = 1) +
    geom_point(data = rates_elev_set, aes(x = set_id, y = rate_mm.yr_set), size = 3, col = "red3") +
    theme_classic() + 
    labs(title = "Elevation Change, 95% Confidence Intervals", subtitle = paste0("Local SLR in blue: ", slr, " +/- ", slr_ci, " mm/yr"), x = "SET", y = "Rate of change (mm/yr)") +
    coord_flip()
```


```{r}
# For statistical comparison purposes. What happens if we average all 36 pins' rates up to the SET level, skipping the average-to-arm step? 


# rates_elev_set2 <- rates_elev_pins %>%
#     group_by(reserve, set_id) %>%
#     summarize(rate_mm.yr_set = mean(rate_mm.yr, na.rm = TRUE),
#               sd_mm.yr = sd(rate_mm.yr, na.rm = TRUE),
#               se_mm.yr = sd_mm.yr/sqrt(n())) %>%
#     mutate(CI95_low = rate_mm.yr_set - 1.96*se_mm.yr,
#            CI95_high = rate_mm.yr_set + 1.96*se_mm.yr) %>%
#     ungroup()
# 
# knitr::kable(rates_elev_set2,
#              caption = "SET change rates calculated from 36 pins rather than 4 arms",
#              col.names = c("Reserve", "SET ID", "Rate (mm/yr)", "stdev", "sterr", "95% CI lower bound", "95% CI upper bound"),
#              digits = 3,
#              align = 'c')
```


# Let's look at Variability  

Here's a histogram of rates at each SET: blue is each pin (n = 36 per SET), gray is each arm position (n = 4 per SET), vertical line is overall average per SET (calculated as average of arms, where arms were the average of 9 pins)

```{r}
ggplot() + 
    geom_histogram(data = rates_elev_pins, aes(rate_mm.yr, stat(density)), fill = "navy", binwidth = 0.5)  +
    geom_histogram(data = rates_elev_arms, aes(rate_mm.yr_arm, stat(density)), fill = "gray50", alpha = 0.5) +
    geom_vline(data = rates_elev_set, aes(xintercept = rate_mm.yr_set), size = 1, col = "red3") +
    facet_wrap(~set_id) +
    theme_bw() +
    labs(title = "Calculated Rates per SET", x = "Rate (mm/yr)", y = "density")



```


